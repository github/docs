import type { Context, Page } from '@/types'
import type { PageTransformer } from './types'
import type {
  QueryT,
  MutationT,
  ObjectT,
  InterfaceT,
  EnumT,
  UnionT,
  InputObjectT,
  ScalarT,
  FieldT,
} from '@/graphql/components/types'
import { renderContent } from '@/content-render/index'
import { loadTemplate } from '@/article-api/lib/load-template'
import { fastTextOnly } from '@/content-render/unified/text-only'
import { extractManualContent } from '@/article-api/lib/graphql-helpers'

/**
 * Transformer for GraphQL reference pages (queries, mutations, objects, etc.)
 * Renders schema items with their fields and arguments
 */
export class GraphQLReferenceTransformer implements PageTransformer {
  templateName = 'graphql-reference.template.md'

  canTransform(page: Page): boolean {
    if (page.autogenerated !== 'graphql') return false

    // Match reference pages that have a specific page type (not index)
    const isReference = page.relativePath.includes('graphql/reference/')
    const isNotIndex = !page.relativePath.endsWith('index.md')

    return isReference && isNotIndex
  }

  async transform(page: Page, pathname: string, context: Context): Promise<string> {
    const currentVersion = context.currentVersion!

    // Determine the page type from the pathname
    const pathParts = pathname.split('/').filter(Boolean)
    const graphqlIndex = pathParts.indexOf('graphql')
    const pageType = pathParts[graphqlIndex + 2] // specific page like 'queries', 'mutations', etc.

    // Import GraphQL data functions dynamically
    const { getGraphqlSchema } = await import('@/graphql/lib/index')

    // Map URL-friendly page type to internal schema key
    const schemaKey = pageType === 'input-objects' ? 'inputObjects' : pageType

    const schema = getGraphqlSchema(currentVersion, schemaKey)

    // Prepare intro and manual content
    const intro = page.intro ? await page.renderProp('intro', context, { textOnly: true }) : ''
    const manualContent = await extractManualContent(page, context)

    // Prepare the schema items based on page type
    let preparedItems: Array<Record<string, unknown>> = []

    switch (schemaKey) {
      case 'queries':
        preparedItems = await Promise.all(
          (schema as QueryT[]).map((item) => this.prepareQuery(item)),
        )
        break
      case 'mutations':
        preparedItems = await Promise.all(
          (schema as MutationT[]).map((item) => this.prepareMutation(item)),
        )
        break
      case 'objects':
        preparedItems = await Promise.all(
          (schema as ObjectT[]).map((item) => this.prepareObject(item)),
        )
        break
      case 'interfaces':
        preparedItems = await Promise.all(
          (schema as InterfaceT[]).map((item) => this.prepareInterface(item)),
        )
        break
      case 'enums':
        preparedItems = await Promise.all((schema as EnumT[]).map((item) => this.prepareEnum(item)))
        break
      case 'unions':
        preparedItems = await Promise.all(
          (schema as UnionT[]).map((item) => this.prepareUnion(item)),
        )
        break
      case 'inputObjects':
        preparedItems = await Promise.all(
          (schema as InputObjectT[]).map((item) => this.prepareInputObject(item)),
        )
        break
      case 'scalars':
        preparedItems = await Promise.all(
          (schema as ScalarT[]).map((item) => this.prepareScalar(item)),
        )
        break
    }

    const templateData: Record<string, unknown> = {
      pageTitle: page.title,
      pageIntro: intro,
      manualContent,
      items: preparedItems,
      pageType: schemaKey,
    }

    const templateContent = loadTemplate(this.templateName)

    return await renderContent(templateContent, {
      ...context,
      ...templateData,
      markdownRequested: true,
    })
  }

  /**
   * Prepare a query item for rendering
   */
  private async prepareQuery(query: QueryT): Promise<Record<string, unknown>> {
    return {
      name: query.name,
      slug: query.name.toLowerCase(),
      description: query.description ? fastTextOnly(query.description) : '',
      type: query.type,
      href: query.href,
      isDeprecated: query.isDeprecated || false,
      deprecationReason: query.deprecationReason
        ? fastTextOnly(query.deprecationReason)
        : undefined,
      args: query.args.map((arg) => ({
        name: arg.name,
        type: arg.type,
        href: arg.href,
        description: arg.description ? fastTextOnly(arg.description) : '',
      })),
    }
  }

  /**
   * Prepare a mutation item for rendering
   */
  private async prepareMutation(mutation: MutationT): Promise<Record<string, unknown>> {
    return {
      name: mutation.name,
      slug: mutation.name.toLowerCase(),
      description: mutation.description ? fastTextOnly(mutation.description) : '',
      isDeprecated: mutation.isDeprecated || false,
      deprecationReason: mutation.deprecationReason
        ? fastTextOnly(mutation.deprecationReason)
        : undefined,
      inputFields: await this.prepareFields(mutation.inputFields),
      returnFields: await this.prepareFields(mutation.returnFields),
    }
  }

  /**
   * Prepare an object item for rendering
   */
  private async prepareObject(object: ObjectT): Promise<Record<string, unknown>> {
    return {
      name: object.name,
      slug: object.name.toLowerCase(),
      description: object.description ? fastTextOnly(object.description) : '',
      isDeprecated: object.isDeprecated || false,
      deprecationReason: object.deprecationReason
        ? fastTextOnly(object.deprecationReason)
        : undefined,
      implements: object.implements || [],
      fields: await this.prepareFields(object.fields),
    }
  }

  /**
   * Prepare an interface item for rendering
   */
  private async prepareInterface(item: InterfaceT): Promise<Record<string, unknown>> {
    return {
      name: item.name,
      slug: item.name.toLowerCase(),
      description: item.description ? fastTextOnly(item.description) : '',
      isDeprecated: item.isDeprecated || false,
      deprecationReason: item.deprecationReason ? fastTextOnly(item.deprecationReason) : undefined,
      fields: await this.prepareFields(item.fields),
    }
  }

  /**
   * Prepare an enum item for rendering
   */
  private async prepareEnum(item: EnumT): Promise<Record<string, unknown>> {
    return {
      name: item.name,
      slug: item.name.toLowerCase(),
      description: item.description ? fastTextOnly(item.description) : '',
      isDeprecated: item.isDeprecated || false,
      deprecationReason: item.deprecationReason ? fastTextOnly(item.deprecationReason) : undefined,
      values: item.values.map((value) => ({
        name: value.name,
        description: value.description ? fastTextOnly(value.description) : '',
      })),
    }
  }

  /**
   * Prepare a union item for rendering
   */
  private async prepareUnion(item: UnionT): Promise<Record<string, unknown>> {
    return {
      name: item.name,
      slug: item.name.toLowerCase(),
      description: item.description ? fastTextOnly(item.description) : '',
      isDeprecated: item.isDeprecated || false,
      deprecationReason: item.deprecationReason ? fastTextOnly(item.deprecationReason) : undefined,
      possibleTypes: item.possibleTypes || [],
    }
  }

  /**
   * Prepare an input object item for rendering
   */
  private async prepareInputObject(item: InputObjectT): Promise<Record<string, unknown>> {
    return {
      name: item.name,
      slug: item.name.toLowerCase(),
      description: item.description ? fastTextOnly(item.description) : '',
      isDeprecated: item.isDeprecated || false,
      deprecationReason: item.deprecationReason ? fastTextOnly(item.deprecationReason) : undefined,
      inputFields: await this.prepareFields(item.inputFields),
    }
  }

  /**
   * Prepare a scalar item for rendering
   */
  private async prepareScalar(item: ScalarT): Promise<Record<string, unknown>> {
    return {
      name: item.name,
      slug: item.name.toLowerCase(),
      description: item.description ? fastTextOnly(item.description) : '',
      isDeprecated: item.isDeprecated || false,
      deprecationReason: item.deprecationReason ? fastTextOnly(item.deprecationReason) : undefined,
    }
  }

  /**
   * Prepare fields for rendering
   */
  private async prepareFields(fields: FieldT[]): Promise<Array<Record<string, unknown>>> {
    return fields.map((field) => ({
      name: field.name,
      type: field.type,
      href: field.href,
      description: field.description ? fastTextOnly(field.description) : '',
      defaultValue: field.defaultValue,
      isDeprecated: field.isDeprecated || false,
      deprecationReason: field.deprecationReason
        ? fastTextOnly(field.deprecationReason)
        : undefined,
      arguments: field.arguments
        ? field.arguments.map((arg) => ({
            name: arg.name,
            description: arg.description ? fastTextOnly(arg.description) : '',
            defaultValue: arg.defaultValue,
            type: {
              name: arg.type.name,
              href: arg.type.href,
            },
          }))
        : undefined,
    }))
  }
}
