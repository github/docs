import type { Context, Page } from '@/types'

/**
 * Link data for landing page sections
 */
export interface LinkData {
  href: string
  title: string
  intro?: string
}

/**
 * Group of links with an optional title
 */
export interface LinkGroup {
  title: string | null
  links: LinkData[]
}

/**
 * Section containing multiple link groups
 */
export interface Section {
  title: string | null
  groups: LinkGroup[]
}

/**
 * Template data structure for landing pages
 */
export interface TemplateData {
  title: string
  intro: string
  sections: Section[]
}

/**
 * Base interface for page-to-markdown transformers
 *
 * Transformers convert autogenerated pages (REST, webhooks, etc.)
 * into markdown format for the Article API
 */
export interface PageTransformer {
  /**
   * Optional: The name of the template file to use for rendering
   * If provided, can be used by helper functions to load the template
   * Example: 'landing-page.template.md'
   */
  templateName?: string

  /**
   * Check if this transformer can handle the given page
   */
  canTransform(page: Page): boolean

  /**
   * Transform the page into markdown format
   * @param page - The page to transform
   * @param pathname - The pathname of the page
   * @param context - The rendering context
   * @param apiVersion - Optional API version (e.g., '2022-11-28' for REST API calendar versioning)
   */
  transform(page: Page, pathname: string, context: Context, apiVersion?: string): Promise<string>
}

/**
 * Registry of available transformers for converting pages to markdown
 *
 * The TransformerRegistry manages a collection of PageTransformer instances
 * and provides a mechanism to find the appropriate transformer for a given page.
 *
 * Transformers are evaluated in registration order. The first transformer
 * whose `canTransform()` method returns true will be selected.
 *
 * @example
 * ```typescript
 * const registry = new TransformerRegistry()
 *
 * // Register transformers in priority order
 * registry.register(new RestTransformer())
 * registry.register(new WebhookTransformer())
 * registry.register(new GraphQLTransformer())
 *
 * // Find and use a transformer
 * const transformer = registry.findTransformer(page)
 * if (transformer) {
 *   const markdown = await transformer.transform(page, pathname, context)
 * }
 * ```
 *
 * @remarks
 * This class is not thread-safe. In server environments with concurrent requests,
 * register all transformers during initialization before handling requests.
 */
export class TransformerRegistry {
  private transformers: PageTransformer[] = []

  /**
   * Register a new transformer
   *
   * Transformers are evaluated in registration order when finding a match.
   * Register more specific transformers before more general ones.
   *
   * @param transformer - The transformer to register
   *
   * @example
   * ```typescript
   * const registry = new TransformerRegistry()
   * registry.register(new RestTransformer())
   * ```
   */
  register(transformer: PageTransformer): void {
    this.transformers.push(transformer)
  }

  /**
   * Find a transformer that can handle the given page
   *
   * Iterates through registered transformers in registration order and returns
   * the first transformer whose `canTransform()` method returns true.
   *
   * @param page - The page to find a transformer for
   * @returns The first matching transformer, or null if:
   *          - The page is null/undefined
   *          - No registered transformer can handle the page
   *
   * @example
   * ```typescript
   * const transformer = registry.findTransformer(page)
   * if (transformer) {
   *   const markdown = await transformer.transform(page, pathname, context)
   * } else {
   *   // Handle case where no transformer is available
   *   console.warn('No transformer found for page:', page.relativePath)
   * }
   * ```
   */
  findTransformer(page: Page): PageTransformer | null {
    if (page == null) {
      return null
    }
    return this.transformers.find((t) => t.canTransform(page)) || null
  }
}
