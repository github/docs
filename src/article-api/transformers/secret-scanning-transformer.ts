import type { Context, Page, SecretScanningData } from '@/types'
import type { PageTransformer } from './types'
import fs from 'fs'
import yaml from 'js-yaml'
import path from 'path'
import { getVersionInfo } from '@/app/lib/constants'
import { liquid, renderContent } from '@/content-render/index'
import { allVersions } from '@/versions/lib/all-versions'
import { loadTemplate } from '@/article-api/lib/load-template'

/**
 * Transformer for Secret Scanning pages.
 * Loads pattern data and converts secret scanning documentation into markdown format using a Liquid template.
 * Used by the Article API to render Secret Scanning documentation dynamically.
 */
export class SecretScanningTransformer implements PageTransformer {
  templateName = 'secret-scanning-page.template.md'

  canTransform(page: Page): boolean {
    return page.autogenerated === 'secret-scanning'
  }

  async transform(page: Page, _pathname: string, context: Context): Promise<string> {
    if (!context.secretScanningData) {
      const currentVersion = context.currentVersion
      if (!currentVersion) throw new Error('currentVersion is required')

      const { isEnterpriseCloud, isEnterpriseServer } = getVersionInfo(currentVersion)
      const versionPath = isEnterpriseCloud
        ? 'ghec'
        : isEnterpriseServer
          ? `ghes-${allVersions[currentVersion].currentRelease}`
          : 'fpt'

      const secretScanningDir = path.join(process.cwd(), 'src/secret-scanning/data/pattern-docs')
      const filepath = path.join(secretScanningDir, versionPath, 'public-docs.yml')

      if (fs.existsSync(filepath)) {
        const data = yaml.load(fs.readFileSync(filepath, 'utf-8')) as SecretScanningData[]

        // Process Liquid in values
        for (const entry of data) {
          // Only process Liquid for the hasValidityCheck field, as in the middleware
          if (typeof entry.hasValidityCheck === 'string' && entry.hasValidityCheck.includes('{%')) {
            // Render Liquid and parse as YAML to get correct boolean type
            entry.hasValidityCheck = yaml.load(
              await liquid.parseAndRender(entry.hasValidityCheck, context),
            ) as boolean
          }

          if (entry.isduplicate) {
            entry.secretType += ' <br/><a href="#token-versions">Token versions</a>'
          }
          if (entry.ismultipart) {
            entry.secretType += ' <br/><a href="#multi-part-secrets">Multi-part secrets</a>'
          }
        }

        context.secretScanningData = data
      } else {
        // If the file does not exist, set to empty array to ensure predictable behavior
        context.secretScanningData = []
      }
    }

    context.markdownRequested = true
    let content = await page.render(context)

    // Strip HTML comments from the rendered content
    content = content.replace(/<!--.*?-->/gs, '')

    // Normalize whitespace after stripping comments
    content = content.replace(/\n{3,}/g, '\n\n').trim()

    const intro = page.intro ? await page.renderProp('intro', context, { textOnly: true }) : ''

    // Prepare template data
    const templateData: Record<string, unknown> = {
      page: {
        title: page.title,
        intro,
      },
      content,
    }

    // Load and render template
    const templateContent = loadTemplate(this.templateName)

    return await renderContent(templateContent, {
      ...context,
      ...templateData,
      markdownRequested: true,
    })
  }
}
