import type { Context, Page } from '@/types'
import type { PageTransformer } from './types'
import { renderContent } from '@/content-render/index'
import { loadTemplate } from '@/article-api/lib/load-template'
import matter from '@gr2m/gray-matter'

const DEBUG = process.env.RUNNER_DEBUG === '1' || process.env.DEBUG === '1'

// GitHub Apps data types
interface GitHubAppsOperation {
  slug: string
  subcategory?: string
  verb: string
  requestPath: string
}

interface GitHubAppsPermissionOperation {
  category: string
  slug: string
  subcategory: string
  verb: string
  requestPath: string
  access: 'admin' | 'write' | 'read'
  'user-to-server': boolean
  'server-to-server': boolean
  'additional-permissions': boolean
}

interface GitHubAppsPermissionGroup {
  displayTitle: string
  permissions: GitHubAppsPermissionOperation[]
}

type GitHubAppsListData = Record<string, GitHubAppsOperation[]>
type GitHubAppsPermissionsData = Record<string, GitHubAppsPermissionGroup>

interface PreparedOperation {
  slug: string
  verb: string
  requestPath: string
  category: string
}

interface PreparedPermissionOperation extends PreparedOperation {
  access: string
  userToServer: boolean
  serverToServer: boolean
  additionalPermissions: boolean
}

interface PreparedListItem {
  category: string
  operations: PreparedOperation[]
}

interface PreparedPermissionItem {
  permissionName: string
  displayTitle: string
  permissions: PreparedPermissionOperation[]
}

// Map content files to their page types from config.json
const PAGE_TYPE_MAP: Record<string, string> = {
  'endpoints-available-for-github-app-installation-access-tokens.md': 'server-to-server-rest',
  'endpoints-available-for-github-app-user-access-tokens.md': 'user-to-server-rest',
  'permissions-required-for-github-apps.md': 'server-to-server-permissions',
  'endpoints-available-for-fine-grained-personal-access-tokens.md': 'fine-grained-pat',
  'permissions-required-for-fine-grained-personal-access-tokens.md': 'fine-grained-pat-permissions',
}

// Page types that display as bullet lists vs tables
const LIST_PAGE_TYPES = new Set([
  'server-to-server-rest',
  'user-to-server-rest',
  'fine-grained-pat',
])

const PERMISSIONS_PAGE_TYPES = new Set([
  'server-to-server-permissions',
  'fine-grained-pat-permissions',
])

/**
 * Transformer for GitHub Apps pages.
 * Converts GitHub Apps autogenerated data into markdown format.
 * Uses a Liquid template for list pages, but builds markdown tables programmatically
 * in TypeScript for permissions pages to avoid Liquid escaping issues.
 */
export class GithubAppsTransformer implements PageTransformer {
  templateName = 'github-apps-page.template.md'

  canTransform(page: Page): boolean {
    return page.autogenerated === 'github-apps'
  }

  async transform(
    page: Page,
    pathname: string,
    context: Context,
    apiVersion?: string,
  ): Promise<string> {
    const startTime = DEBUG ? Date.now() : 0
    if (DEBUG) console.log(`[DEBUG] GitHubAppsTransformer: ${pathname}`)

    // Import getAppsData dynamically to avoid circular dependencies
    const { getAppsData } = await import('@/github-apps/lib/index')

    // Extract version from context
    const currentVersion = context.currentVersion!

    // Use the provided apiVersion, or fall back to the latest from context
    const effectiveApiVersion =
      apiVersion ||
      (context.currentVersionObj?.apiVersions?.length
        ? context.currentVersionObj.latestApiVersion
        : undefined)

    // Determine page type from the page's relative path
    const filename = page.relativePath.split('/').pop()
    const pageType = filename ? PAGE_TYPE_MAP[filename] : undefined

    if (!pageType) {
      throw new Error(`Unknown GitHub Apps page type for path: ${page.relativePath}`)
    }

    // Get the GitHub Apps data
    const appsData = await getAppsData(pageType, currentVersion, effectiveApiVersion)

    // Prepare manual content
    let manualContent = ''
    if (page.markdown) {
      const { content } = matter(page.markdown)
      // GitHub Apps pages don't have the automated marker, so we render all markdown content
      if (content.trim()) {
        manualContent = await renderContent(content, {
          ...context,
          markdownRequested: true,
        })

        // Strip HTML comments and normalize whitespace
        manualContent = manualContent
          .replace(/<!--.*?-->/gs, '')
          .replace(/\n{3,}/g, '\n\n')
          .trim()
      }
    }

    // Prepare data for template based on page type
    const isListPage = LIST_PAGE_TYPES.has(pageType)
    const isPermissionsPage = PERMISSIONS_PAGE_TYPES.has(pageType)

    const templateData = await this.prepareTemplateData(
      page,
      appsData,
      context,
      manualContent,
      isListPage,
      isPermissionsPage,
    )

    // Load template
    const templateContent = loadTemplate(this.templateName)

    // For permissions pages, we need to construct the tables manually to avoid Liquid escaping
    let finalContent: string
    if (isPermissionsPage) {
      // Build the intro manually
      let introMarkdown = `# ${templateData.page.title}\n\n`
      if (templateData.page.intro) {
        introMarkdown += `${templateData.page.intro}\n\n`
      }
      if (templateData.manualContent) {
        introMarkdown += `${templateData.manualContent}\n\n`
      }

      // Build the tables manually
      let tablesMarkdown = ''
      for (const item of templateData.items as PreparedPermissionItem[]) {
        tablesMarkdown += `## ${item.displayTitle}\n\n`
        tablesMarkdown += '| Endpoint | Access | Tokens | Additional Permissions |\n'
        tablesMarkdown += '|----------|--------|--------|------------------------|\n'

        for (const perm of item.permissions) {
          const lang = context.currentLanguage || 'en'
          const version =
            context.currentVersion === 'free-pro-team@latest' ? '' : `${context.currentVersion}/`
          const endpoint = `[\`${perm.verb} ${perm.requestPath}\`](/${lang}/${version}rest/${perm.category}#${perm.slug})`

          let tokens = ''
          if (perm.userToServer) {
            tokens += `[UAT](/${lang}/${version}apps/creating-github-apps/authenticating-with-a-github-app/authenticating-with-a-github-app-on-behalf-of-a-user)`
          }
          if (perm.userToServer && perm.serverToServer) {
            tokens += '<br>'
          }
          if (perm.serverToServer) {
            tokens += `[IAT](/${lang}/${version}apps/creating-github-apps/authenticating-with-a-github-app/authenticating-as-a-github-app-installation)`
          }

          const additionalPerms = perm.additionalPermissions ? '✓' : '✗'

          tablesMarkdown += `| ${endpoint} | ${perm.access} | ${tokens} | ${additionalPerms} |\n`
        }
        tablesMarkdown += '\n'
      }

      finalContent = introMarkdown + tablesMarkdown
    } else {
      // For list pages, Liquid template works fine
      finalContent = await renderContent(templateContent, {
        ...context,
        pageData: templateData.page,
        manualContent: templateData.manualContent,
        isListPage: templateData.isListPage,
        items: templateData.items,
        markdownRequested: true,
      })
    }

    if (DEBUG)
      console.log(
        `[DEBUG] GitHubAppsTransformer.transform completed in ${Date.now() - startTime}ms`,
      )
    return finalContent
  }

  /**
   * Prepare data for the Liquid template
   */
  private async prepareTemplateData(
    page: Page,
    appsData: GitHubAppsListData | GitHubAppsPermissionsData,
    context: Context,
    manualContent: string,
    isListPage: boolean,
    isPermissionsPage: boolean,
  ): Promise<{
    page: { title: string; intro: string }
    manualContent: string
    isListPage: boolean
    isPermissionsPage: boolean
    items: PreparedListItem[] | PreparedPermissionItem[]
  }> {
    // Prepare page intro
    const intro = page.intro ? await page.renderProp('intro', context, { textOnly: true }) : ''

    // Get categories without subcategories from rest lib
    const { categoriesWithoutSubcategories } = await import('@/rest/lib/index')

    // Prepare items based on page type
    let preparedItems: PreparedListItem[] | PreparedPermissionItem[] = []

    if (isListPage) {
      // For list pages, data is organized by category -> array of operations
      preparedItems = Object.entries(appsData as GitHubAppsListData).map(
        ([category, operations]) => ({
          category,
          operations: operations.map((op) =>
            this.prepareOperation(op, category, categoriesWithoutSubcategories),
          ),
        }),
      )
    } else if (isPermissionsPage) {
      // For permissions pages, data is organized by permission name -> permission object
      preparedItems = Object.entries(appsData as GitHubAppsPermissionsData).map(
        ([permissionName, permissionObject]) => {
          const { displayTitle, permissions } = permissionObject
          // Sort by access level (admin, write, read)
          const adminPermissions = permissions.filter((p) => p.access === 'admin')
          const writePermissions = permissions.filter((p) => p.access === 'write')
          const readPermissions = permissions.filter((p) => p.access === 'read')
          const sortedPermissions = [...adminPermissions, ...writePermissions, ...readPermissions]

          return {
            permissionName,
            displayTitle,
            permissions: sortedPermissions.map((op) =>
              this.preparePermissionOperation(op, categoriesWithoutSubcategories),
            ),
          }
        },
      )
    }

    return {
      page: {
        title: page.title,
        intro,
      },
      manualContent,
      isListPage,
      isPermissionsPage,
      items: preparedItems,
    }
  }

  /**
   * Prepare a single operation for list-based rendering (endpoints)
   */
  private prepareOperation(
    operation: GitHubAppsOperation,
    category: string,
    categoriesWithoutSubcategories: string[],
  ): PreparedOperation {
    const fullCategory = operation.subcategory
      ? categoriesWithoutSubcategories.includes(category)
        ? category
        : `${category}/${operation.subcategory}`
      : category

    return {
      slug: operation.slug,
      verb: operation.verb.toUpperCase(),
      requestPath: operation.requestPath,
      category: fullCategory,
    }
  }

  /**
   * Prepare a single operation for permissions-based rendering (tables)
   */
  private preparePermissionOperation(
    operation: GitHubAppsPermissionOperation,
    categoriesWithoutSubcategories: string[],
  ): PreparedPermissionOperation {
    const category = categoriesWithoutSubcategories.includes(operation.category)
      ? operation.category
      : `${operation.category}/${operation.subcategory}`

    return {
      slug: operation.slug,
      verb: operation.verb.toUpperCase(),
      requestPath: operation.requestPath,
      access: operation.access,
      category,
      userToServer: operation['user-to-server'] || false,
      serverToServer: operation['server-to-server'] || false,
      additionalPermissions: operation['additional-permissions'] || false,
    }
  }
}
