import type { Context, Page } from '@/types'
import type { PageTransformer } from './types'
import type { CategorizedEvents } from '@/audit-logs/types'
import { renderContent } from '@/content-render/index'
import { loadTemplate } from '@/article-api/lib/load-template'
import matter from '@gr2m/gray-matter'

/**
 * Transformer for Audit Logs pages
 * Converts audit log events and their data into markdown format using a Liquid template
 */
export class AuditLogsTransformer implements PageTransformer {
  templateName = 'audit-logs-page.template.md'

  canTransform(page: Page): boolean {
    return page.autogenerated === 'audit-logs'
  }

  async transform(page: Page, pathname: string, context: Context): Promise<string> {
    // Import audit log lib dynamically to avoid circular dependencies
    const { getCategorizedAuditLogEvents, getCategoryNotes, resolveReferenceLinksToMarkdown } =
      await import('@/audit-logs/lib/index')

    // Extract version from context
    const currentVersion = context.currentVersion!

    let pageType = ''
    if (pathname.includes('/security-log-events')) {
      pageType = 'user'
    } else if (pathname.includes('/audit-log-events-for-your-enterprise')) {
      pageType = 'enterprise'
    } else if (pathname.includes('/audit-log-events-for-your-organization')) {
      pageType = 'organization'
    } else {
      throw new Error(`Unknown audit log page type for path: ${pathname}`)
    }

    // Get the audit log events data
    const categorizedEvents = getCategorizedAuditLogEvents(pageType, currentVersion)
    const categoryNotes = getCategoryNotes()

    // Prepare manual content
    let manualContent = ''
    if (page.markdown) {
      const markerIndex = page.markdown.indexOf(
        '<!-- Content after this section is automatically generated -->',
      )
      if (markerIndex > 0) {
        const { content } = matter(page.markdown)
        const manualContentMarkerIndex = content.indexOf(
          '<!-- Content after this section is automatically generated -->',
        )
        if (manualContentMarkerIndex > 0) {
          const rawManualContent = content.substring(0, manualContentMarkerIndex).trim()
          if (rawManualContent) {
            manualContent = await renderContent(rawManualContent, {
              ...context,
              markdownRequested: true,
            })
          }
        }
      }
    }

    // Prepare data for template
    const templateData = await this.prepareTemplateData(
      page,
      categorizedEvents,
      categoryNotes,
      context,
      manualContent,
      resolveReferenceLinksToMarkdown,
    )

    // Load and render template
    const templateContent = loadTemplate(this.templateName)

    // Render the template with Liquid
    const rendered = await renderContent(templateContent, {
      ...context,
      ...templateData,
      markdownRequested: true,
    })

    return rendered
  }

  /**
   * Prepare data for the Liquid template
   */
  private async prepareTemplateData(
    page: Page,
    categorizedEvents: CategorizedEvents,
    categoryNotes: Record<string, string>,
    context: Context,
    manualContent: string,
    resolveReferenceLinksToMarkdown: (docsReferenceLinks: string, context: any) => Promise<string>,
  ): Promise<Record<string, unknown>> {
    // Prepare page intro
    const intro = page.intro ? await page.renderProp('intro', context, { textOnly: true }) : ''

    // Sort categories and events
    const sortedCategorizedEvents: CategorizedEvents = {}
    const sortedCategories = Object.keys(categorizedEvents).sort((a, b) => a.localeCompare(b))

    for (const category of sortedCategories) {
      // Create a copy of the events array to avoid mutating the cache
      const events = [...categorizedEvents[category]].sort((a, b) =>
        a.action.localeCompare(b.action),
      )
      sortedCategorizedEvents[category] = await Promise.all(
        events.map(async (event) => {
          const newEvent = { ...event }
          if (newEvent.docs_reference_links && newEvent.docs_reference_links !== 'N/A') {
            newEvent.docs_reference_links = await resolveReferenceLinksToMarkdown(
              newEvent.docs_reference_links,
              context,
            )
          }
          return newEvent
        }),
      )
    }

    return {
      page: {
        title: page.title,
        intro,
      },
      manualContent,
      categorizedEvents: sortedCategorizedEvents,
      categoryNotes,
    }
  }
}
