import { addError, ellipsify } from 'markdownlint-rule-helpers'

import { getRange } from '@/content-linter/lib/helpers/utils'
import frontmatter from '@/frame/lib/read-frontmatter'

// Mapping of outdated terms to their new replacements
// Order matters - longer phrases must come first to avoid partial matches
const TERMINOLOGY_REPLACEMENTS = [
  // Beta variations → public preview (longer phrases first)
  ['limited public beta', 'public preview'],
  ['public beta', 'public preview'],
  ['private beta', 'private preview'],
  ['beta', 'public preview'],

  // Alpha → private preview
  ['alpha', 'private preview'],

  // Deprecated variations → closing down
  ['deprecation', 'closing down'],
  ['deprecated', 'closing down'],

  // Sunset → retired
  ['sunset', 'retired'],
]

// Precompile RegExp objects for better performance
const COMPILED_REGEXES = TERMINOLOGY_REPLACEMENTS.map(([outdatedTerm, replacement]) => ({
  regex: new RegExp(`(?<!\\w|-|_)${outdatedTerm.replace(/\s+/g, '\\s+')}(?!\\w|-|_)`, 'gi'),
  outdatedTerm,
  replacement,
}))

/**
 * Find all non-overlapping matches of outdated terminology in a line
 * @param {string} line - The line of text to search
 * @returns {Array} Array of match objects with start, end, text, replacement, and outdatedTerm
 */
function findOutdatedTerminologyMatches(line) {
  const foundMatches = []

  // Check each outdated term (in order - longest first)
  for (const { regex, outdatedTerm, replacement } of COMPILED_REGEXES) {
    // Reset regex state for each line
    regex.lastIndex = 0
    let match

    while ((match = regex.exec(line)) !== null) {
      // Check if this match overlaps with any existing matches
      const overlaps = foundMatches.some(
        (existing) =>
          (match.index >= existing.start && match.index < existing.end) ||
          (match.index + match[0].length > existing.start &&
            match.index + match[0].length <= existing.end) ||
          (match.index <= existing.start && match.index + match[0].length >= existing.end),
      )

      if (!overlaps) {
        foundMatches.push({
          start: match.index,
          end: match.index + match[0].length,
          text: match[0],
          replacement: replacement,
          outdatedTerm: outdatedTerm,
        })
      }
    }
  }

  // Sort matches by position for consistent ordering
  return foundMatches.sort((a, b) => a.start - b.start)
}

export const outdatedReleasePhaseTerminology = {
  names: ['GHD046', 'outdated-release-phase-terminology'],
  description:
    'Outdated release phase terminology should be replaced with current GitHub terminology',
  tags: ['terminology', 'consistency', 'release-phases'],
  severity: 'error',
  function: (params, onError) => {
    // Skip autogenerated files
    const frontmatterString = params.frontMatterLines.join('\n')
    const fm = frontmatter(frontmatterString).data
    if (fm && fm.autogenerated) return

    // Check all lines for outdated terminology
    for (let i = 0; i < params.lines.length; i++) {
      const line = params.lines[i]
      const lineNumber = i + 1

      // Find all matches on this line
      const foundMatches = findOutdatedTerminologyMatches(line)

      // Report all found matches
      for (const matchInfo of foundMatches) {
        const range = getRange(line, matchInfo.text)
        const errorMessage = `Replace outdated terminology "${matchInfo.text}" with "${matchInfo.replacement}"`

        // Provide a fix suggestion
        const fixInfo = {
          editColumn: matchInfo.start + 1,
          deleteCount: matchInfo.text.length,
          insertText: matchInfo.replacement,
        }

        addError(onError, lineNumber, errorMessage, ellipsify(line), range, fixInfo)
      }
    }
  },
}
