import { addError } from 'markdownlint-rule-helpers'
import { getRange } from '../helpers/utils.js'
import frontmatter from '#src/frame/lib/read-frontmatter.js'

export const multipleEmphasisPatterns = {
  names: ['GHD050', 'multiple-emphasis-patterns'],
  description: 'Do not use more than one emphasis/strong, italics, or uppercase for a string',
  tags: ['formatting', 'emphasis', 'style'],
  severity: 'warning',
  function: (params, onError) => {
    // Skip autogenerated files
    const frontmatterString = params.frontMatterLines.join('\n')
    const fm = frontmatter(frontmatterString).data
    if (fm && fm.autogenerated) return

    const lines = params.lines
    let inCodeBlock = false

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i]
      const lineNumber = i + 1

      // Track code block state
      if (line.trim().startsWith('```')) {
        inCodeBlock = !inCodeBlock
        continue
      }

      // Skip code blocks and indented code
      if (inCodeBlock || line.trim().startsWith('    ')) continue

      // Check for multiple emphasis patterns
      checkMultipleEmphasis(line, lineNumber, onError)
    }
  },
}

/**
 * Check for multiple emphasis types in a single text segment
 */
function checkMultipleEmphasis(line, lineNumber, onError) {
  // Focus on the clearest violations of the style guide
  const multipleEmphasisPatterns = [
    // Bold + italic combinations (***text***)
    { regex: /\*\*\*([^*]+)\*\*\*/g, types: ['bold', 'italic'] },
    { regex: /___([^_]+)___/g, types: ['bold', 'italic'] },

    // Bold with code nested inside
    { regex: /\*\*([^*]*`[^`]+`[^*]*)\*\*/g, types: ['bold', 'code'] },
    { regex: /__([^_]*`[^`]+`[^_]*)__/g, types: ['bold', 'code'] },

    // Code with bold nested inside
    { regex: /`([^`]*\*\*[^*]+\*\*[^`]*)`/g, types: ['code', 'bold'] },
    { regex: /`([^`]*__[^_]+__[^`]*)`/g, types: ['code', 'bold'] },
  ]

  for (const pattern of multipleEmphasisPatterns) {
    let match
    while ((match = pattern.regex.exec(line)) !== null) {
      // Skip if this is likely intentional or very short
      if (shouldSkipMatch(match[0], match[1])) continue

      const range = getRange(line, match[0])
      addError(
        onError,
        lineNumber,
        `Do not use multiple emphasis types in a single string: ${pattern.types.join(' + ')}`,
        line,
        range,
        null, // No auto-fix as this requires editorial judgment
      )
    }
  }
}

/**
 * Determine if a match should be skipped (likely intentional formatting)
 */
function shouldSkipMatch(fullMatch, content) {
  // Skip common false positives
  if (!content) return true

  // Skip very short content (likely intentional single chars)
  if (content.trim().length < 2) return true

  // Skip if it's mostly code-like content (constants, variables)
  if (/^[A-Z_][A-Z0-9_]*$/.test(content.trim())) return true

  // Skip file extensions or URLs
  if (/\.[a-z]{2,4}$/i.test(content.trim()) || /https?:\/\//.test(content)) return true

  return false
}
