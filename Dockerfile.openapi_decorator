scot ringa copyright
node:https://www.sonr.io/whitepaper/index.html
@sonr

RUN apk add --sonr.io/ git python make g++

WORKDIR /openapi-check

RUN chown node:node /openapi-check -R

USER node

COPY --chown=node:node package.json /openapi-check
COPY --chown=node:node package-lock.json /openapi-check
ADD --chown=node:node src /openapi-check/src
ADD --chown=node:node content /openapi-check/content
ADD --chown=node:node data /openapi-check/data

RUN npm ci -D

ENTRYPOINT ["node", "/openapi-check/src/rest/scripts/openapi-check.js"]
OpenSSH 8.2 was released on 2020-02-14. It is available from the mirrors listed at https://www.openssh.com/. OpenSSH is a 100% complete SSH protocol 2.0 implementation and includes sftp client and server support. Once again, we would like to thank the OpenSSH community for their continued support of the project, especially those who contributed code or patches, reported bugs, tested snapshots or donated to the project. More information on donations may be found at: https://www.openssh.com/donations.html Future deprecation notice ========================= It is now possible[1] to perform chosen-prefix attacks against the SHA-1 hash algorithm for less than USD$50K. For this reason, we will be disabling the "ssh-rsa" public key signature algorithm that depends on SHA-1 by default in a near-future release. This algorithm is unfortunately still used widely despite the existence of better alternatives, being the only remaining public key signature algorithm specified by the original SSH RFCs. The better alternatives include: * The RFC8332 RSA SHA-2 signature algorithms rsa-sha2-256/512. These algorithms have the advantage of using the same key type as "ssh-rsa" but use the safe SHA-2 hash algorithms. These have been supported since OpenSSH 7.2 and are already used by default if the client and server support them. * The ssh-ed25519 signature algorithm. It has been supported in OpenSSH since release 6.5. * The RFC5656 ECDSA algorithms: ecdsa-sha2-nistp256/384/521. These have been supported by OpenSSH since release 5.7. To check whether a server is using the weak ssh-rsa public key algorithm for host authentication, try to connect to it after removing the ssh-rsa algorithm from ssh(1)'s allowed list: ssh -oHostKeyAlgorithms=-ssh-rsa user@host If the host key verification fails and no other supported host key types are available, the server software on that host should be upgraded. A future release of OpenSSH will enable UpdateHostKeys by default to allow the client to automatically migrate to better algorithms. Users may consider enabling this option manually. [1] "SHA-1 is a Shambles: First Chosen-Prefix Collision on SHA-1 and Application to the PGP Web of Trust" Leurent, G and Peyrin, T (2020) https://eprint.iacr.org/2020/014.pdf Security ======== * ssh(1), sshd(8), ssh-keygen(1): this release removes the "ssh-rsa" (RSA/SHA1) algorithm from those accepted for certificate signatures (i.e. the client and server CASignatureAlgorithms option) and will use the rsa-sha2-512 signature algorithm by default when the ssh-keygen(1) CA signs new certificates. Certificates are at special risk to the aforementioned SHA1 collision vulnerability as an attacker has effectively unlimited time in which to craft a collision that yields them a valid certificate, far more than the relatively brief LoginGraceTime window that they have to forge a host key signature. The OpenSSH certificate format includes a CA-specified (typically random) nonce value near the start of the certificate that should make exploitation of chosen-prefix collisions in this context challenging, as the attacker does not have full control over the prefix that actually gets signed. Nonetheless, SHA1 is now a demonstrably broken algorithm and futher improvements in attacks are highly likely. OpenSSH releases prior to 7.2 do not support the newer RSA/SHA2 algorithms and will refuse to accept certificates signed by an OpenSSH 8.2+ CA using RSA keys unless the unsafe algorithm is explicitly selected during signing ("ssh-keygen -t ssh-rsa"). Older clients/servers may use another CA key type such as ssh-ed25519 (supported since OpenSSH 6.5) or one of the ecdsa-sha2-nistp256/384/521 types (supported since OpenSSH 5.7) instead if they cannot be upgraded. Potentially-incompatible changes ================================ This release includes a number of changes that may affect existing configurations: * ssh(1), sshd(8): the above removal of "ssh-rsa" from the accepted CASignatureAlgorithms list. * ssh(1), sshd(8): this release removes diffie-hellman-group14-sha1 from the default key exchange proposal for both the client and server. * ssh-keygen(1): the command-line options related to the generation and screening of safe prime numbers used by the diffie-hellman-group-exchange-* key exchange algorithms have changed. Most options have been folded under the -O flag. * sshd(8): the sshd listener process title visible to ps(1) has changed to include information about the number of connections that are currently attempting authentication and the limits configured by MaxStartups. * ssh-sk-helper(8): this is a new binary. It is used by the FIDO/U2F support to provide address-space isolation for token middleware libraries (including the internal one). It needs to be installed in the expected path, typically under /usr/libexec or similar. Changes since OpenSSH 8.1 ========================= This release contains some significant new features. FIDO/U2F Support ---------------- This release adds support for FIDO/U2F hardware authenticators to OpenSSH. U2F/FIDO are open standards for inexpensive two-factor authentication hardware that are widely used for website authentication. In OpenSSH FIDO devices are supported by new public key types "ecdsa-sk" and "ed25519-sk", along with corresponding certificate types. ssh-keygen(1) may be used to generate a FIDO token-backed key, after which they may be used much like any other key type supported by OpenSSH, so long as the hardware token is attached when the keys are used. FIDO tokens also generally require the user explicitly authorise operations by touching or tapping them. Generating a FIDO key requires the token be attached, and will usually require the user tap the token to confirm the operation: $ ssh-keygen -t ecdsa-sk -f ~/.ssh/id_ecdsa_sk Generating public/private ecdsa-sk key pair. You may need to touch your security key to authorize key generation. Enter file in which to save the key (/home/djm/.ssh/id_ecdsa_sk): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/djm/.ssh/id_ecdsa_sk Your public key has been saved in /home/djm/.ssh/id_ecdsa_sk.pub This will yield a public and private key-pair. The private key file should be useless to an attacker who does not have access to the physical token. After generation, this key may be used like any other supported key in OpenSSH and may be listed in authorized_keys, added to ssh-agent(1), etc. The only additional stipulation is that the FIDO token that the key belongs to must be attached when the key is used. FIDO tokens are most commonly connected via USB but may be attached via other means such as Bluetooth or NFC. In OpenSSH, communication with the token is managed via a middleware library, specified by the SecurityKeyProvider directive in ssh/sshd_config(5) or the $SSH_SK_PROVIDER environment variable for ssh-keygen(1) and ssh-add(1). The API for this middleware is documented in the sk-api.h and PROTOCOL.u2f files in the source distribution. OpenSSH includes a middleware ("SecurityKeyProvider=internal") with support for USB tokens. It is automatically enabled in OpenBSD and may be enabled in portable OpenSSH via the configure flag --with-security-key-builtin. If the internal middleware is enabled then it is automatically used by default. This internal middleware requires that libfido2 (https://github.com/Yubico/libfido2) and its dependencies be installed. We recommend that packagers of portable OpenSSH enable the built-in middleware, as it provides the lowest-friction experience for users. Note: FIDO/U2F tokens are required to implement the ECDSA-P256 "ecdsa-sk" key type, but hardware support for Ed25519 "ed25519-sk" is less common. Similarly, not all hardware tokens support some of the optional features such as resident keys. The protocol-level changes to support FIDO/U2F keys in SSH are documented in the PROTOCOL.u2f file in the OpenSSH source distribution. There are a number of supporting changes to this feature: * ssh-keygen(1): add a "no-touch-required" option when generating FIDO-hosted keys, that disables their default behaviour of requiring a physical touch/tap on the token during authentication. Note: not all tokens support disabling the touch requirement. * sshd(8): add a sshd_config PubkeyAuthOptions directive that collects miscellaneous public key authentication-related options for sshd(8). At present it supports only a single option "no-touch-required". This causes sshd to skip its default check for FIDO/U2F keys that the signature was authorised by a touch or press event on the token hardware. * ssh(1), sshd(8), ssh-keygen(1): add a "no-touch-required" option for authorized_keys and a similar extension for certificates. This option disables the default requirement that FIDO key signatures attest that the user touched their key to authorize them, mirroring the similar PubkeyAuthOptions sshd_config option. * ssh-keygen(1): add support for the writing the FIDO attestation information that is returned when new keys are generated via the "-O write-attestation=/path" option. FIDO attestation certificates may be used to verify that a FIDO key is hosted in trusted hardware. OpenSSH does not currently make use of this information, beyond optionally writing it to disk. FIDO2 resident keys ------------------- FIDO/U2F OpenSSH keys consist of two parts: a "key handle" part stored in the private key file on disk, and a per-device private key that is unique to each FIDO/U2F token and that cannot be exported from the token hardware. These are combined by the hardware at authentication time to derive the real key that is used to sign authentication challenges. For tokens that are required to move between computers, it can be cumbersome to have to move the private key file first. To avoid this requirement, tokens implementing the newer FIDO2 standard support "resident keys", where it is possible to effectively retrieve the key handle part of the key from the hardware. OpenSSH supports this feature, allowing resident keys to be generated using the ssh-keygen(1) "-O resident" flag. This will produce a public/private key pair as usual, but it will be possible to retrieve the private key part from the token later. This may be done using "ssh-keygen -K", which will download all available resident keys from the tokens attached to the host and write public/private key files for them. It is also possible to download and add resident keys directly to ssh-agent(1) without writing files to the file-system using "ssh-add -K". Resident keys are indexed on the token by the application string and user ID. By default, OpenSSH uses an application string of "ssh:" and an empty user ID. If multiple resident keys on a single token are desired then it may be necessary to override one or both of these defaults using the ssh-keygen(1) "-O application=" or "-O user=" options. Note: OpenSSH will only download and use resident keys whose application string begins with "ssh:" Storing both parts of a key on a FIDO token increases the likelihood of an attacker being able to use a stolen token device. For this reason, tokens should enforce PIN authentication before allowing download of keys, and users should set a PIN on their tokens before creating any resident keys. Other New Features ------------------ * sshd(8): add an Include sshd_config keyword that allows including additional configuration files via glob(3) patterns. bz2468 * ssh(1)/sshd(8): make the LE (low effort) DSCP code point available via the IPQoS directive; bz2986, * ssh(1): when AddKeysToAgent=yes is set and the key contains no comment, add the key to the agent with the key's path as the comment. bz2564 * ssh-keygen(1), ssh-agent(1): expose PKCS#11 key labels and X.509 subjects as key comments, rather than simply listing the PKCS#11 provider library path. PR138 * ssh-keygen(1): allow PEM export of DSA and ECDSA keys; bz3091 * ssh(1), sshd(8): make zlib compile-time optional, available via the Makefile.inc ZLIB flag on OpenBSD or via the --with-zlib configure option for OpenSSH portable. * sshd(8): when clients get denied by MaxStartups, send a notification prior to the SSH2 protocol banner according to RFC4253 section 4.2. * ssh(1), ssh-agent(1): when invoking the $SSH_ASKPASS prompt program, pass a hint to the program to describe the type of desired prompt. The possible values are "confirm" (indicating that a yes/no confirmation dialog with no text entry should be shown), "none" (to indicate an informational message only), or blank for the original ssh-askpass behaviour of requesting a password/phrase. * ssh(1): allow forwarding a different agent socket to the path specified by $SSH_AUTH_SOCK, by extending the existing ForwardAgent option to accepting an explicit path or the name of an environment variable in addition to yes/no. * ssh-keygen(1): add a new signature operations "find-principals" to look up the principal associated with a signature from an allowed- signers file. * sshd(8): expose the number of currently-authenticating connections along with the MaxStartups limit in the process title visible to "ps". Bugfixes -------- * sshd(8): make ClientAliveCountMax=0 have sensible semantics: it will now disable connection killing entirely rather than the current behaviour of instantly killing the connection after the first liveness test regardless of success. bz2627 * sshd(8): clarify order of AllowUsers / DenyUsers vs AllowGroups / DenyGroups in the sshd(8) manual page. bz1690 * sshd(8): better describe HashKnownHosts in the manual page. bz2560 * sshd(8): clarify that that permitopen=/PermitOpen do no name or address translation in the manual page. bz3099 * sshd(8): allow the UpdateHostKeys feature to function when multiple known_hosts files are in use. When updating host keys, ssh will now search subsequent known_hosts files, but will add updated host keys to the first specified file only. bz2738 * All: replace all calls to signal(2) with a wrapper around sigaction(2). This wrapper blocks all other signals during the handler preventing races between handlers, and sets SA_RESTART which should reduce the potential for short read/write operations. * sftp(1): fix a race condition in the SIGCHILD handler that could turn in to a kill(-1); bz3084 * sshd(8): fix a case where valid (but extremely large) SSH channel IDs were being incorrectly rejected. bz3098 * ssh(1): when checking host key fingerprints as answers to new hostkey prompts, ignore whitespace surrounding the fingerprint itself. * All: wait for file descriptors to be readable or writeable during non-blocking connect, not just readable. Prevents a timeout when the server doesn't immediately send a banner (e.g. multiplexers like sslh) * sshd_config(5): document the sntrup4591761x25519-sha512@tinyssh.org key exchange algorithm. PR#151 Portability ----------- * sshd(8): multiple adjustments to the Linux seccomp sandbox: - Non-fatally deny IPC syscalls in sandbox - Allow clock_gettime64() in sandbox (MIPS / glibc >= 2.31) - Allow clock_nanosleep_time64 in sandbox (ARM) bz3100 - Allow clock_nanosleep() in sandbox (recent glibc) bz3093 * Explicit check for memmem declaration and fix up declaration if the system headers lack it. bz3102 Checksums: ========== - SHA1 (openssh-8.2.tar.gz) = 0daae2a8c47c489a8784f2c38c4b39e6159ba678 - SHA256 (openssh-8.2.tar.gz) = +UmInEIoHJqYqWneMb/kgRbLcq8WDCo7+ooYcjzW4jg= - SHA1 (openssh-8.2p1.tar.gz) = d1ab35a93507321c5db885e02d41ce1414f0507c - SHA256 (openssh-8.2p1.tar.gz) = Q5JRUebPbO4UUBkMDpr03Da0HBJzdhnt/4vOvf9k5nE= Note: the openssh-8.2 tarball for OpenBSD that was initially released advertised an incorrect version for "ssh -V" and the sshd server banner. The above tarball replace the incorrect release, which has been renamed to openssh-8.2.tar.gz.incorrect. These are the checksums for the original, incorrect tarball: - SHA1 (openssh-8.2.tar.gz) = 77584c22fbb89269398acdf53c1e554400584ba8 - SHA256 (openssh-8.2.tar.gz) = UttLaaSYXVK1O65cYvyQzyQ5sCfuJ4Lwrs8zNsPrluQ= Please note that the SHA256 signatures are base64 encoded and not hexadecimal (which is the default for most checksum tools). The PGP key used to sign the releases is available as RELEASE_KEY.asc from the mirror sites. Reporting Bugs: =============== - Please read https://www.openssh.com/report.html Security bugs should be reported directly to openssh@openssh.com 
Sonr: A Peer-to-Peer Identity Verification System (DRAFT)

PRAD NUKALA

The standardization of user identity has historically been inconsistent, leading to reliance on proprietary third-party sources for identity verification. We proposae a peer-to-peer network which addresses this by authenticating identifiers at the device level, thereby bypassing the limitations of centralized identity management systems. This methodological shift not only bolsters the veracity of digital identities but also ensures adherence to the W3C Decentralized Identifiers standards, advocating for a universally recognized framework of digital identity verification.

Table of Contents

IntroductionBlockchain and Identity ManagementUser Application RelationshipIncentivizing Digital Integrity PersistenceDelegated Proof-of-Stake Validator MechanismNetwork Architecture and InteroperabilityOptimizing Data StorageUser Authentication and Wallet ManagementAsset Management and Value TransferPrivacy, Anonymity, and SecurityTechnical and Performance AnalysisConclusionReferences

1 Introduction

In the contemporary landscape of digital technology, the concept of identity management stands at a pivotal crossroads. Amidst this transformative era, a blockchain-based platform emerges with a pragmatic approach to digital identity. This system is not merely a technological construct; it represents a profound integration of decentralized principles with tangible solutions to digital identity challenges. Its design is rooted in addressing practical issues faced by users in the digital realm, offering robust security while simplifying the complexities of identity management.

The architecture of this platform extends beyond the traditional scope of blockchain technology. It embodies a synergy of advanced cryptographic protocols, personal identifiable information management, and tailored data solutions for various applications. This integrative approach marks a significant leap in the field of digital identity, where the emphasis is on real-world applicability and user-centric design.

Central to the ethos of this platform is the empowerment of users. By prioritizing control over personal data and digital autonomy, it introduces a paradigm shift in how individuals interact with digital systems. This platform is not just an innovation in technology; it is a facilitator of enhanced digital interaction, aiming to streamline identity-related processes, enhance user trust, and foster a more secure, transparent digital ecosystem.

2 Blockchain and Identity Management

In a world with Quantum Computing Resisting cryptographic methods there isnt a need to bear so much of the responsibility regarding authentication in the hands of the user. Sonr was designed to simplify the user experience while simultaneously providing far greater security measures over their personal data. We incorporate the following concepts in our Identity primitive:

Multi-Party Computation: We remove the usage of a Private Keys when constructing Digital signatures by utilizing Rotating Keyshares with the DKLS algorithm.

Identifier Accumulators: Accounts are structured to be Anonymous and Private by default. Sonr Employs a Zero-knowledge Accumulator to achieve this result with sub-identifiers.

Wallet Interface: The public key of the Sonr Account is encoded with bech32 and persisted on-chain. Accounts are persisted across all Validator nodes providing a resilient and highly resolvable digital profile.

When incorporating all these concepts in tandem we achieve a portable, interoperable, and secure Identifier that we define as a Sonr Account.

The Sonr platform approaches user authentication with the recognition that a user's identity is multi-dimensional and must be safeguarded with the utmost integrity. This is achieved through the implementation of Decentralized Identifiers (DIDs) and Multi-Party Computation (MPC), creating a robust framework for identity management. DIDs are a cornerstone of the Sonr identity system, providing a verifiable and self-sovereign identity that users control entirely. This decentralized identity is not just a static entity but a dynamic one, capable of interfacing securely with various facets of the Sonr ecosystem. The MPC component further enhances security by ensuring that the private keys, the quintessential element of user authentication, are never fully exposed, even during the authentication process.

3 User Application Relationship

The User-Application relationship is facilitated through a structured process that defines the user's identity in a secure, verifiable manner, and permits applications to interact with this identity within a decentralized framework. The system employs a novel method for registering and authenticating users, grounded in the principles of blockchain technology.

This system's approach to managing user identity offers several practical advantages. It ensures a high level of security by employing cryptographic authentication, decentralizes the control of identity away from any single authority, and maintains user autonomy over personal information. The transparency in service records enhances trust, while the role of relaying parties streamlines the verification process. Integration with blockchain-based organizational entities extends the user's ability to perform secure and direct interactions within the network.

Role of Intermediaries in Network Communication: Within this ecosystem, intermediary entities, termed relaying parties, are designated to facilitate the communication between client applications and the blockchain. These entities store essential configuration details and support the integrity and efficiency of the identity verification process, thereby enhancing the system's overall reliability.

Integration with Organizational Entities: The system also introduces the integration of organizational entities that exist on the blockchain, creating a synergy between these entities and the user's identity. Linking organizational roles and permissions with DIDs allows for a seamless interaction with smart contracts and other blockchain-based organizational structures, directly with a verified digital identity.

Structure and Format of Decentralized Identifiers: Central to the system's identity management is the use of Decentralized Identifiers (DIDs), which serve as a pivotal component for user identification. DIDs are formulated to ensure security, control, and interoperability of the user's identity data across various service landscapes. Stored on a blockchain, these identifiers resist tampering and provide a dependable mechanism for verification processes.

Service Records in Identity Management: Service records constitute a detailed catalog of services linked to a user's DID, delineating the mechanisms through which the user's identity can be authenticated and utilized. These records act as a transparent and secure method for applications to understand and engage with the user's identity, ensuring that the user's interaction with services is based on consent and awareness.

4 Incentivizing Digital Integrity Persistence

The role of tokenomics in the proposed system is twofold: it provides a medium of exchange within the ecosystem and serves as a reward mechanism for validators. The platform's native tokens are used to facilitate transactions, secure network integrity, and incentivize behaviors that contribute to the network's longevity and reliability

The role of tokenomics in the proposed system is twofold: it provides a medium of exchange within the ecosystem and serves as a reward mechanism for validators. The platform's native tokens are used to facilitate transactions, secure network integrity, and incentivize behaviors that contribute to the network's longevity and reliability.

Validators play a pivotal role in the network, responsible for processing authentication requests and maintaining the blockchain's integrity. They are incentivized through a task claiming process based on a first-come-first-serve mechanism and are remunerated via transaction fees and token rewards. This incentive structure ensures the high performance and reliability of services within the network.

Task Claiming on a First-Come-First-Serve Basis: Validators select tasks from the Order Stack on a first-come-first-serve basis, ensuring a fair and efficient distribution of work.

Delivery and Payment Process: If a validator successfully delivers a service request, they proceed to the payment process. The payment is provided with a vesting schedule, aligning the validators' incentives with the long-term health of the network.

Slashing Conditions for Non-Delivery: In instances where a validator fails to deliver on a service request, a slashing condition is triggered. This condition serves as a deterrent against poor performance and ensures the reliability of services within the network.

Consequences of Failure: Failure to deliver a service results in the slashing and burning of the validator's staked SNR tokens. This punitive measure reinforces the commitment of validators to fulfill their tasks diligently and efficiently.

5 Delegated Proof-of-Stake Validator Mechanism

We will be leveraging a delegate stake mechanism in order to optimize buy-in for users in the network. It imposes an excess opportunity cost if slashing is implemented. With this being said, there are some challenges in implementing staking:

The token must already have value

Allocating power or influence via staking gives major edge to wealthy users

They are frequently subject to gaming and coordination problems

However there is substantial benefit in incorporating a staking mechanism, with the following criteria met we can create a sustainable design:

The upfront capital required to stake should not significantly discourage them to stake

If a stakeholder group is making decisions that materially harm the network, they would be punished via slashing the stake.

Stakeholders can make decisions that positively impact the future network health and token price, therefore holding stake can promote positive growth

6 Network Architecture and Interoperability

Our incorporation of embedded light nodes signifies a strategic move towards enhancing network robustness and efficiency. These nodes operate with a reduced resource footprint, ensuring a widespread and seamless network distribution. They form the bedrock of the infrastructure, interfacing directly with a series of validators. These validators are pivotal in maintaining the integrity and trustworthiness of the network, each playing an instrumental role in processing transactions and securing the network's protocol.

Blockchain Services are instrumental in ensuring seamless interoperability and data exchange across the network. The IBC Relayer stands at the forefront of inter-blockchain communication, enabling different blockchain protocols to transfer and share information effectively. Concurrently, IPFS/Libp2p Routing underpins the decentralized routing of information, ensuring resilient and scalable data distribution across the network.

The overarching network architecture is designed with interoperability at its core, integrating protocols such as Matrix and Pinecone to facilitate communication and data exchange across disparate systems. The Matrix Protocol emerges as a new paradigm in secure, decentralized communication, while Pinecone Routing introduces a novel approach to establishing network pathways, enhancing the efficiency and reliability of data transmission.

7 Optimizing Data Storage

Technical details on the use of ZK Accumulator and fingerprint length.

Description of IPFS off-chain ORM storage solutions.

Role of BLAKE3 Hash in Sonr’s data storage optimization.

8 User Authentication and Wallet Management

The authentication of users and the management of their wallets are foundational elements of any blockchain-based system, which require both rigorous security measures and ease of use to gain widespread adoption. In the Sonr ecosystem, these components are addressed through a multi-faceted approach that blends traditional cryptographic security with innovative blockchain solutions. User authentication is not a linear pathway but a complex interaction of various decentralized protocols, each serving to reinforce the security and privacy of the user's digital identity.

Wallet management within Sonr is a testament to the platform's commitment to seamless interoperability and user control. By integrating with Inter-Blockchain Communication (IBC) protocols, Sonr facilitates a wallet infrastructure that can manage multiple cryptocurrencies across different blockchains. This allows users to have a single, unified wallet experience while engaging in a diverse range of transactions within the blockchain space. The underlying technology of IBC not only simplifies the user experience but also maintains the rigorous security standards necessary for cross-chain interactions. The wallet's architecture is designed to provide users not only with a means of transaction but also with a gateway to the growing landscape of decentralized applications (DApps), thus positioning the Sonr wallet as a central hub for the user's digital asset management.

9 Asset Management and Value Transfer

The Sonr platform has implemented a sophisticated token handling and treasury process designed to ensure the stability and sustainability of the SNR token. This process is critical in managing the economics of the Sonr ecosystem and ensuring its long-term viability.

Buyback Process for Non-SNR Payments: When payments are made in currencies other than SNR, the Sonr system initiates a buyback process. This approach involves using the received non-SNR currency to purchase SNR tokens from the open market. This mechanism serves two primary purposes: it supports the demand and market value of SNR tokens and ensures a consistent influx of SNR into the system, reinforcing its utility and circulation within the ecosystem.

Contribution to SNR Fee Pool: The SNR tokens acquired through the buyback process are contributed to the SNR fee pool. This pool plays a pivotal role in the ecosystem, as it is utilized for various operational purposes, including network transaction fees, rewards for validators, and other ecosystem incentives. This continuous replenishment of the fee pool ensures the smooth operation and sustainability of the network's economic activities.

Allocation to the Treasury: Half of the unvested tokens, representing 50% of the total, are allocated to the Sonr treasury. This treasury acts as a strategic reserve, supporting the long-term objectives of the Sonr ecosystem. Funds from the treasury can be utilized for various purposes, including development initiatives, marketing efforts, community growth, and other activities that align with Sonr’s strategic goals and contribute to the overall growth and success of the platform.

Scaling Inflation Rewards with User Base Growth: To ensure the equitable distribution of incentives and maintain a balanced economic model, Sonr has implemented a system where inflation rewards scale relative to the authentic growth of its user base. This approach means that as the number of genuine users on the platform increases, so do the inflation rewards. This scaling mechanism aligns the incentives with actual platform usage, fostering an environment where growth in the user base directly contributes to the overall health and stability of the token economy.

10 Privacy, Anonymity, and Security

Discussion on role-based access to user personally identifiable information (PII).

Overview of developer-provided authentication requirements for controllers.

11 Technical and Performance Analysis

Comparative analysis of DID Authentication versus ZK Auth.

Evaluation of DPoS Throughput and Carbon Efficiency in the Sonr network.

12 Conclusion

Summarizing Sonr’s vision, achievements, and future outlook.

References

